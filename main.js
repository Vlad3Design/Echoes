/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => EchoesPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian2 = require("obsidian");

// src/EchoesView.ts
var import_obsidian = require("obsidian");
var VIEW_TYPE_ECHOES = "echoes-view";
var EchoesView = class extends import_obsidian.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.currentAnalysis = [];
    this.activeTab = "overview";
    this.plugin = plugin;
    this.analyzer = plugin.getAnalyzer();
    this.wordCloudGenerator = plugin.getWordCloudGenerator();
  }
  getViewType() {
    return VIEW_TYPE_ECHOES;
  }
  getDisplayText() {
    return "Echoes";
  }
  getIcon() {
    return "bar-chart-2";
  }
  async onOpen() {
    const container = this.containerEl.children[1];
    container.empty();
    container.addClass("echoes-view");
    this.renderView();
    await this.refreshAnalysis();
  }
  renderView() {
    const container = this.containerEl.children[1];
    const header = container.createDiv("echoes-header");
    const title = header.createEl("h2", { text: "Echoes - Concept Frequency Analyzer" });
    title.addClass("echoes-title");
    const refreshBtn = header.createEl("button", { text: "Refresh" });
    refreshBtn.addClass("echoes-refresh-btn");
    refreshBtn.addEventListener("click", () => this.refreshAnalysis());
    const tabContainer = container.createDiv("echoes-tabs");
    const tabs = [
      { id: "overview", label: "Overview", icon: "\u{1F4CA}" },
      { id: "wordcloud", label: "Word Cloud", icon: "\u2601\uFE0F" },
      { id: "frequency", label: "Frequency Chart", icon: "\u{1F4C8}" },
      { id: "tags", label: "Tags", icon: "\u{1F3F7}\uFE0F" },
      { id: "details", label: "Details", icon: "\u{1F4CB}" }
    ];
    tabs.forEach((tab) => {
      const tabBtn = tabContainer.createEl("button", {
        text: `${tab.icon} ${tab.label}`
      });
      tabBtn.addClass("echoes-tab");
      if (tab.id === this.activeTab) {
        tabBtn.addClass("active");
      }
      tabBtn.addEventListener("click", () => this.switchTab(tab.id));
    });
    const content = container.createDiv("echoes-content");
    content.id = "echoes-content-area";
    this.addStyles();
  }
  switchTab(tabId) {
    this.activeTab = tabId;
    const tabs = this.containerEl.querySelectorAll(".echoes-tab");
    tabs.forEach((tab) => tab.removeClass("active"));
    const activeTab = Array.from(tabs).find(
      (tab) => {
        var _a;
        return (_a = tab.textContent) == null ? void 0 : _a.includes(this.getTabLabel(tabId));
      }
    );
    if (activeTab) {
      activeTab.addClass("active");
    }
    this.renderContent();
  }
  getTabLabel(tabId) {
    const labels = {
      "overview": "Overview",
      "wordcloud": "Word Cloud",
      "frequency": "Frequency Chart",
      "tags": "Tags",
      "details": "Details"
    };
    return labels[tabId] || "Unknown";
  }
  renderContent() {
    const contentArea = this.containerEl.querySelector("#echoes-content-area");
    if (!contentArea)
      return;
    contentArea.empty();
    if (this.currentAnalysis.length === 0) {
      contentArea.innerHTML = '<p class="echoes-empty">No analysis data available. Click Refresh to analyze your vault.</p>';
      return;
    }
    const mergedAnalysis = this.analyzer.mergeAnalysisResults(this.currentAnalysis);
    switch (this.activeTab) {
      case "overview":
        this.renderOverview(contentArea, mergedAnalysis);
        break;
      case "wordcloud":
        this.renderWordCloud(contentArea, mergedAnalysis);
        break;
      case "frequency":
        this.renderFrequencyChart(contentArea, mergedAnalysis);
        break;
      case "tags":
        this.renderTags(contentArea, mergedAnalysis);
        break;
      case "details":
        this.renderDetails(contentArea, mergedAnalysis);
        break;
    }
  }
  renderOverview(container, analysis) {
    const overview = container.createDiv("echoes-overview");
    const statsContainer = overview.createDiv("echoes-stats-container");
    this.wordCloudGenerator.generateStatsSummary([analysis], statsContainer);
    const topWordsSection = overview.createDiv("echoes-section");
    topWordsSection.createEl("h3", { text: "Top 10 Words" });
    const topWordsList = topWordsSection.createDiv("echoes-top-words");
    analysis.topWords.slice(0, 10).forEach((word, index) => {
      const wordItem = topWordsList.createDiv("echoes-word-item");
      wordItem.innerHTML = `
				<span class="echoes-word-rank">${index + 1}.</span>
				<span class="echoes-word-text">${word.word}</span>
				<span class="echoes-word-count">${word.count}</span>
				<span class="echoes-word-percentage">(${word.percentage.toFixed(1)}%)</span>
			`;
    });
    const actionsSection = overview.createDiv("echoes-section");
    actionsSection.createEl("h3", { text: "Quick Actions" });
    const actionsContainer = actionsSection.createDiv("echoes-actions");
    const analyzeCurrentBtn = actionsContainer.createEl("button", { text: "\u{1F50D} Analyze Current File" });
    analyzeCurrentBtn.addClass("echoes-action-btn");
    analyzeCurrentBtn.addEventListener("click", () => {
      const activeFile = this.app.workspace.getActiveFile();
      if (activeFile) {
        this.plugin.analyzeCurrentFile(activeFile);
      }
    });
    const exportBtn = actionsContainer.createEl("button", { text: "\u{1F4CA} Export Data" });
    exportBtn.addClass("echoes-action-btn");
    exportBtn.addEventListener("click", () => this.exportAnalysis());
  }
  renderWordCloud(container, analysis) {
    const wordCloudSection = container.createDiv("echoes-wordcloud-section");
    wordCloudSection.createEl("h3", { text: "Word Cloud Visualization" });
    const cloudContainer = wordCloudSection.createDiv("echoes-wordcloud-container");
    this.wordCloudGenerator.generateWordCloudSVG(
      analysis.topWords,
      cloudContainer,
      {
        width: Math.min(800, container.clientWidth - 40),
        height: 400
      }
    );
  }
  renderFrequencyChart(container, analysis) {
    const chartSection = container.createDiv("echoes-chart-section");
    chartSection.createEl("h3", { text: "Word Frequency Chart" });
    const chartContainer = chartSection.createDiv("echoes-chart-container");
    this.wordCloudGenerator.generateBarChart(
      analysis.topWords,
      chartContainer,
      25
    );
  }
  renderTags(container, analysis) {
    const tagsSection = container.createDiv("echoes-tags-section");
    tagsSection.createEl("h3", { text: "Tag Analysis" });
    if (analysis.tags.length === 0) {
      tagsSection.createEl("p", { text: "No tags found in your vault. Use #tags in your notes to see them here." });
      return;
    }
    const tagsContainer = tagsSection.createDiv("echoes-tags-container");
    this.wordCloudGenerator.generateTagCloud(analysis.tags, tagsContainer);
    const tagsListSection = tagsSection.createDiv("echoes-section");
    tagsListSection.createEl("h4", { text: "All Tags" });
    const tagsList = tagsListSection.createDiv("echoes-tags-list");
    analysis.tags.forEach((tag, index) => {
      const tagItem = tagsList.createDiv("echoes-tag-item");
      tagItem.innerHTML = `
				<span class="echoes-tag-name">#${tag.word}</span>
				<span class="echoes-tag-count">${tag.count}</span>
				<span class="echoes-tag-percentage">(${tag.percentage.toFixed(1)}%)</span>
			`;
    });
  }
  renderDetails(container, analysis) {
    const detailsSection = container.createDiv("echoes-details-section");
    detailsSection.createEl("h3", { text: "Detailed Analysis" });
    const infoContainer = detailsSection.createDiv("echoes-analysis-info");
    infoContainer.innerHTML = `
			<div class="echoes-info-item">
				<strong>Files Analyzed:</strong> ${this.currentAnalysis.length}
			</div>
			<div class="echoes-info-item">
				<strong>Total Words:</strong> ${analysis.totalWords.toLocaleString()}
			</div>
			<div class="echoes-info-item">
				<strong>Unique Words:</strong> ${analysis.uniqueWords.toLocaleString()}
			</div>
			<div class="echoes-info-item">
				<strong>Analysis Date:</strong> ${analysis.timestamp.toLocaleString()}
			</div>
		`;
    const wordsSection = detailsSection.createDiv("echoes-section");
    wordsSection.createEl("h4", { text: `All Words (Top ${Math.min(100, analysis.wordFrequencies.length)})` });
    const wordsTable = wordsSection.createEl("table", { cls: "echoes-words-table" });
    const headerRow = wordsTable.createEl("tr");
    headerRow.innerHTML = "<th>Rank</th><th>Word</th><th>Count</th><th>Percentage</th>";
    analysis.wordFrequencies.slice(0, 100).forEach((word, index) => {
      const row = wordsTable.createEl("tr");
      row.innerHTML = `
				<td>${index + 1}</td>
				<td>${word.word}</td>
				<td>${word.count}</td>
				<td>${word.percentage.toFixed(2)}%</td>
			`;
    });
  }
  async refreshAnalysis() {
    try {
      const files = this.app.vault.getMarkdownFiles();
      const analysisPromises = files.map(async (file) => {
        const content = await this.app.vault.read(file);
        return this.analyzer.analyzeText(content, file.basename);
      });
      this.currentAnalysis = await Promise.all(analysisPromises);
      this.renderContent();
    } catch (error) {
      console.error("Error refreshing analysis:", error);
    }
  }
  updateAnalysis(analysis) {
    this.currentAnalysis = analysis;
    this.renderContent();
  }
  exportAnalysis() {
    if (this.currentAnalysis.length === 0) {
      return;
    }
    const mergedAnalysis = this.analyzer.mergeAnalysisResults(this.currentAnalysis);
    const exportData = {
      timestamp: new Date().toISOString(),
      summary: {
        totalWords: mergedAnalysis.totalWords,
        uniqueWords: mergedAnalysis.uniqueWords,
        filesAnalyzed: this.currentAnalysis.length
      },
      topWords: mergedAnalysis.topWords.slice(0, 50),
      tags: mergedAnalysis.tags,
      wordFrequencies: mergedAnalysis.wordFrequencies.slice(0, 200)
    };
    const dataStr = JSON.stringify(exportData, null, 2);
    const dataBlob = new Blob([dataStr], { type: "application/json" });
    const url = URL.createObjectURL(dataBlob);
    const link = document.createElement("a");
    link.href = url;
    link.download = `echoes-analysis-${new Date().toISOString().split("T")[0]}.json`;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
  }
  addStyles() {
    const styleEl = document.createElement("style");
    styleEl.textContent = `
			.echoes-view {
				padding: 20px;
				height: 100%;
				overflow-y: auto;
			}
			
			.echoes-header {
				display: flex;
				justify-content: space-between;
				align-items: center;
				margin-bottom: 20px;
				border-bottom: 1px solid var(--background-modifier-border);
				padding-bottom: 15px;
			}
			
			.echoes-title {
				margin: 0;
				color: var(--text-accent);
			}
			
			.echoes-refresh-btn {
				padding: 8px 16px;
				background: var(--interactive-accent);
				color: var(--text-on-accent);
				border: none;
				border-radius: 4px;
				cursor: pointer;
			}
			
			.echoes-tabs {
				display: flex;
				gap: 5px;
				margin-bottom: 20px;
				border-bottom: 1px solid var(--background-modifier-border);
			}
			
			.echoes-tab {
				padding: 10px 15px;
				background: transparent;
				border: none;
				border-bottom: 2px solid transparent;
				cursor: pointer;
				transition: all 0.2s;
			}
			
			.echoes-tab:hover {
				background: var(--background-modifier-hover);
			}
			
			.echoes-tab.active {
				border-bottom-color: var(--interactive-accent);
				color: var(--interactive-accent);
			}
			
			.echoes-content {
				min-height: 400px;
			}
			
			.echoes-empty {
				text-align: center;
				color: var(--text-muted);
				font-style: italic;
				margin: 40px 0;
			}
			
			.echoes-stats {
				display: grid;
				grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
				gap: 15px;
				margin-bottom: 30px;
			}
			
			.echoes-stat-item {
				text-align: center;
				padding: 15px;
				background: var(--background-secondary);
				border-radius: 8px;
			}
			
			.echoes-stat-value {
				font-size: 1.5em;
				font-weight: bold;
				color: var(--interactive-accent);
			}
			
			.echoes-stat-label {
				font-size: 0.9em;
				color: var(--text-muted);
				margin-top: 5px;
			}
			
			.echoes-section {
				margin-bottom: 30px;
			}
			
			.echoes-section h3, .echoes-section h4 {
				margin-bottom: 15px;
				color: var(--text-accent);
			}
			
			.echoes-top-words, .echoes-tags-list {
				display: grid;
				gap: 8px;
			}
			
			.echoes-word-item, .echoes-tag-item {
				display: grid;
				grid-template-columns: auto 1fr auto auto;
				gap: 10px;
				padding: 8px;
				background: var(--background-secondary);
				border-radius: 4px;
				align-items: center;
			}
			
			.echoes-word-rank {
				font-weight: bold;
				color: var(--text-muted);
			}
			
			.echoes-word-text, .echoes-tag-name {
				font-weight: 500;
			}
			
			.echoes-word-count, .echoes-tag-count {
				color: var(--interactive-accent);
				font-weight: bold;
			}
			
			.echoes-word-percentage, .echoes-tag-percentage {
				color: var(--text-muted);
				font-size: 0.9em;
			}
			
			.echoes-actions {
				display: flex;
				gap: 10px;
				flex-wrap: wrap;
			}
			
			.echoes-action-btn {
				padding: 10px 15px;
				background: var(--interactive-accent);
				color: var(--text-on-accent);
				border: none;
				border-radius: 4px;
				cursor: pointer;
			}
			
			.echoes-wordcloud-container {
				text-align: center;
				background: var(--background-secondary);
				border-radius: 8px;
				padding: 20px;
			}
			
			.echoes-bar-chart {
				display: grid;
				gap: 8px;
			}
			
			.echoes-bar-item {
				display: grid;
				grid-template-columns: 120px 1fr auto;
				gap: 10px;
				align-items: center;
			}
			
			.echoes-bar-label {
				font-weight: 500;
				text-align: right;
			}
			
			.echoes-bar-container {
				background: var(--background-modifier-border);
				height: 20px;
				border-radius: 10px;
				overflow: hidden;
			}
			
			.echoes-bar-fill {
				height: 100%;
				background: var(--interactive-accent);
				transition: width 0.3s ease;
			}
			
			.echoes-bar-count {
				font-size: 0.9em;
				color: var(--text-muted);
				white-space: nowrap;
			}
			
			.echoes-tag-cloud {
				display: flex;
				flex-wrap: wrap;
				gap: 8px;
				margin-bottom: 20px;
			}
			
			.echoes-tag {
				padding: 4px 8px;
				background: var(--tag-background);
				color: var(--tag-color);
				border-radius: 12px;
				cursor: pointer;
				transition: all 0.2s;
			}
			
			.echoes-tag:hover {
				background: var(--interactive-accent);
				color: var(--text-on-accent);
			}
			
			.echoes-words-table {
				width: 100%;
				border-collapse: collapse;
				margin-top: 15px;
			}
			
			.echoes-words-table th,
			.echoes-words-table td {
				padding: 8px 12px;
				text-align: left;
				border-bottom: 1px solid var(--background-modifier-border);
			}
			
			.echoes-words-table th {
				background: var(--background-secondary);
				font-weight: 600;
			}
			
			.echoes-analysis-info {
				display: grid;
				gap: 8px;
				margin-bottom: 20px;
			}
			
			.echoes-info-item {
				padding: 8px;
				background: var(--background-secondary);
				border-radius: 4px;
			}
		`;
    document.head.appendChild(styleEl);
  }
};

// src/FrequencyAnalyzer.ts
var FrequencyAnalyzer = class {
  constructor(settings) {
    this.settings = settings;
    this.updateExcludeWords();
  }
  updateSettings(settings) {
    this.settings = settings;
    this.updateExcludeWords();
  }
  updateExcludeWords() {
    this.excludeWordsSet = new Set(
      this.settings.excludeWords.toLowerCase().split(",").map((word) => word.trim()).filter((word) => word.length > 0)
    );
  }
  normalizeWord(word) {
    return word.replace(/ă/g, "a").replace(/â/g, "a").replace(/î/g, "i").replace(/ș/g, "s").replace(/ț/g, "t");
  }
  analyzeText(content, fileName = "Unknown") {
    const { cleanText, tags, headers } = this.parseMarkdown(content);
    const words = this.tokenizeText(cleanText);
    const filteredWords = this.filterWords(words);
    const wordCounts = this.countWords(filteredWords);
    const totalWords = filteredWords.length;
    const uniqueWords = wordCounts.size;
    const wordFrequencies = this.createFrequencyArray(wordCounts, totalWords);
    const topWords = wordFrequencies.slice(0, this.settings.maxWords).sort((a, b) => b.count - a.count);
    const tagFrequencies = this.settings.includeTags ? this.analyzeTags(tags) : [];
    return {
      fileName,
      totalWords,
      uniqueWords,
      wordFrequencies,
      topWords,
      tags: tagFrequencies,
      headers: this.settings.includeHeaders ? headers : [],
      timestamp: new Date()
    };
  }
  parseMarkdown(content) {
    const tags = [];
    const headers = [];
    let cleanText = content;
    const tagMatches = content.match(/#[\w\-_]+/g);
    if (tagMatches) {
      tags.push(...tagMatches.map((tag) => tag.substring(1)));
    }
    const headerMatches = content.match(/^#{1,6}\s+(.+)$/gm);
    if (headerMatches) {
      headers.push(...headerMatches.map((header) => header.replace(/^#+\s+/, "")));
    }
    cleanText = cleanText.replace(/```[\s\S]*?```/g, " ").replace(/`[^`]+`/g, " ").replace(/\[([^\]]+)\]\([^)]+\)/g, "$1").replace(/!\[([^\]]*)\]\([^)]+\)/g, "$1").replace(/[*_~`]/g, " ").replace(/^#{1,6}\s+.+$/gm, " ").replace(/<[^>]*>/g, " ").replace(/\s+/g, " ").trim();
    return { cleanText, tags, headers };
  }
  tokenizeText(text) {
    return text.toLowerCase().replace(/[^a-zA-Z0-9\s\u0103\u00e2\u00ee\u0219\u021b\u0102\u00c2\u00ce\u0218\u021a'-]/g, " ").split(/\s+/).filter((word) => word.length > 0);
  }
  filterWords(words) {
    return words.filter((word) => {
      if (word.length < this.settings.minWordLength) {
        return false;
      }
      if (this.excludeWordsSet.has(word) || this.excludeWordsSet.has(this.normalizeWord(word))) {
        return false;
      }
      if (/^\d+$/.test(word)) {
        return false;
      }
      if (word.length < 2) {
        return false;
      }
      return true;
    });
  }
  countWords(words) {
    const counts = /* @__PURE__ */ new Map();
    for (const word of words) {
      counts.set(word, (counts.get(word) || 0) + 1);
    }
    return counts;
  }
  createFrequencyArray(wordCounts, totalWords) {
    const frequencies = [];
    for (const [word, count] of wordCounts.entries()) {
      frequencies.push({
        word,
        count,
        percentage: count / totalWords * 100
      });
    }
    return frequencies.sort((a, b) => b.count - a.count);
  }
  analyzeTags(tags) {
    const tagCounts = this.countWords(tags);
    const totalTags = tags.length;
    return this.createFrequencyArray(tagCounts, totalTags);
  }
  analyzeVault(files) {
    return files.map((file) => this.analyzeText(file.content, file.name));
  }
  mergeAnalysisResults(results) {
    if (results.length === 0) {
      return {
        fileName: "Empty Vault",
        totalWords: 0,
        uniqueWords: 0,
        wordFrequencies: [],
        topWords: [],
        tags: [],
        headers: [],
        timestamp: new Date()
      };
    }
    const combinedWordCounts = /* @__PURE__ */ new Map();
    const combinedTagCounts = /* @__PURE__ */ new Map();
    const allHeaders = [];
    let totalWords = 0;
    for (const result of results) {
      totalWords += result.totalWords;
      allHeaders.push(...result.headers);
      for (const wordFreq of result.wordFrequencies) {
        combinedWordCounts.set(
          wordFreq.word,
          (combinedWordCounts.get(wordFreq.word) || 0) + wordFreq.count
        );
      }
      for (const tagFreq of result.tags) {
        combinedTagCounts.set(
          tagFreq.word,
          (combinedTagCounts.get(tagFreq.word) || 0) + tagFreq.count
        );
      }
    }
    const wordFrequencies = this.createFrequencyArray(combinedWordCounts, totalWords);
    const tagFrequencies = this.createFrequencyArray(combinedTagCounts, totalWords);
    const topWords = wordFrequencies.slice(0, this.settings.maxWords).sort((a, b) => b.count - a.count);
    return {
      fileName: `Combined Analysis (${results.length} files)`,
      totalWords,
      uniqueWords: combinedWordCounts.size,
      wordFrequencies,
      topWords,
      tags: tagFrequencies,
      headers: allHeaders,
      timestamp: new Date()
    };
  }
};

// src/WordCloudGenerator.ts
var WordCloudGenerator = class {
  constructor() {
    this.defaultOptions = {
      width: 800,
      height: 400,
      padding: 5,
      fontFamily: "Impact, Arial, sans-serif",
      minFontSize: 12,
      maxFontSize: 60,
      colors: [
        "#1f77b4",
        "#ff7f0e",
        "#2ca02c",
        "#d62728",
        "#9467bd",
        "#8c564b",
        "#e377c2",
        "#7f7f7f",
        "#bcbd22",
        "#17becf"
      ],
      spiral: "archimedean"
    };
  }
  generateWordCloudSVG(wordFrequencies, container, options = {}) {
    const opts = { ...this.defaultOptions, ...options };
    container.innerHTML = "";
    const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    svg.setAttribute("width", opts.width.toString());
    svg.setAttribute("height", opts.height.toString());
    svg.style.fontFamily = opts.fontFamily;
    const maxCount = Math.max(...wordFrequencies.map((w) => w.count));
    const minCount = Math.min(...wordFrequencies.map((w) => w.count));
    const words = wordFrequencies.slice(0, 50).map((word, index) => {
      const fontSize = this.calculateFontSize(word.count, minCount, maxCount, opts.minFontSize, opts.maxFontSize);
      const color = opts.colors[index % opts.colors.length];
      return {
        text: word.word,
        size: fontSize,
        color,
        count: word.count,
        percentage: word.percentage
      };
    });
    this.layoutWordsGrid(words, svg, opts);
    container.appendChild(svg);
  }
  calculateFontSize(count, minCount, maxCount, minSize, maxSize) {
    if (maxCount === minCount) {
      return minSize;
    }
    const ratio = (count - minCount) / (maxCount - minCount);
    return minSize + (maxSize - minSize) * ratio;
  }
  layoutWordsGrid(words, svg, options) {
    const { width, height, padding } = options;
    const cols = Math.ceil(Math.sqrt(words.length));
    const cellWidth = width / cols;
    const cellHeight = height / Math.ceil(words.length / cols);
    words.forEach((word, index) => {
      const row = Math.floor(index / cols);
      const col = index % cols;
      const x = col * cellWidth + cellWidth / 2;
      const y = row * cellHeight + cellHeight / 2;
      const textElement = document.createElementNS("http://www.w3.org/2000/svg", "text");
      textElement.setAttribute("x", x.toString());
      textElement.setAttribute("y", y.toString());
      textElement.setAttribute("text-anchor", "middle");
      textElement.setAttribute("dominant-baseline", "middle");
      textElement.setAttribute("font-size", word.size.toString());
      textElement.setAttribute("fill", word.color);
      textElement.style.cursor = "pointer";
      textElement.textContent = word.text;
      const title = document.createElementNS("http://www.w3.org/2000/svg", "title");
      title.textContent = `${word.text}: ${word.count} occurrences (${word.percentage.toFixed(1)}%)`;
      textElement.appendChild(title);
      textElement.addEventListener("click", () => {
        this.onWordClick(word);
      });
      svg.appendChild(textElement);
    });
  }
  generateBarChart(wordFrequencies, container, maxWords = 20) {
    container.innerHTML = "";
    const chartContainer = document.createElement("div");
    chartContainer.className = "echoes-bar-chart";
    const topWords = wordFrequencies.slice(0, maxWords);
    const maxCount = Math.max(...topWords.map((w) => w.count));
    topWords.forEach((word, index) => {
      const bar = document.createElement("div");
      bar.className = "echoes-bar-item";
      const label = document.createElement("div");
      label.className = "echoes-bar-label";
      label.textContent = word.word;
      const barContainer = document.createElement("div");
      barContainer.className = "echoes-bar-container";
      const barFill = document.createElement("div");
      barFill.className = "echoes-bar-fill";
      barFill.style.width = `${word.count / maxCount * 100}%`;
      const count = document.createElement("div");
      count.className = "echoes-bar-count";
      count.textContent = `${word.count} (${word.percentage.toFixed(1)}%)`;
      barContainer.appendChild(barFill);
      bar.appendChild(label);
      bar.appendChild(barContainer);
      bar.appendChild(count);
      chartContainer.appendChild(bar);
    });
    container.appendChild(chartContainer);
  }
  generateTagCloud(tagFrequencies, container) {
    container.innerHTML = "";
    if (tagFrequencies.length === 0) {
      container.innerHTML = '<p class="echoes-empty">No tags found</p>';
      return;
    }
    const tagContainer = document.createElement("div");
    tagContainer.className = "echoes-tag-cloud";
    const maxCount = Math.max(...tagFrequencies.map((t) => t.count));
    tagFrequencies.forEach((tag, index) => {
      const tagElement = document.createElement("span");
      tagElement.className = "echoes-tag";
      tagElement.textContent = `#${tag.word}`;
      tagElement.title = `${tag.count} occurrences (${tag.percentage.toFixed(1)}%)`;
      const size = 0.8 + tag.count / maxCount * 1.2;
      tagElement.style.fontSize = `${size}em`;
      tagElement.addEventListener("click", () => {
        this.onWordClick(tag);
      });
      tagContainer.appendChild(tagElement);
    });
    container.appendChild(tagContainer);
  }
  onWordClick(word) {
    console.log("Word clicked:", word);
  }
  generateStatsSummary(analysisResults, container) {
    container.innerHTML = "";
    if (analysisResults.length === 0) {
      container.innerHTML = '<p class="echoes-empty">No analysis data available</p>';
      return;
    }
    const result = analysisResults[0];
    const stats = document.createElement("div");
    stats.className = "echoes-stats";
    const statsItems = [
      { label: "Total Words", value: result.totalWords.toLocaleString() },
      { label: "Unique Words", value: result.uniqueWords.toLocaleString() },
      { label: "Files Analyzed", value: analysisResults.length.toString() },
      { label: "Tags Found", value: result.tags.length.toString() },
      { label: "Headers Found", value: result.headers.length.toString() }
    ];
    statsItems.forEach((item) => {
      const statItem = document.createElement("div");
      statItem.className = "echoes-stat-item";
      const value = document.createElement("div");
      value.className = "echoes-stat-value";
      value.textContent = item.value;
      const label = document.createElement("div");
      label.className = "echoes-stat-label";
      label.textContent = item.label;
      statItem.appendChild(value);
      statItem.appendChild(label);
      stats.appendChild(statItem);
    });
    container.appendChild(stats);
  }
};

// main.ts
var DEFAULT_SETTINGS = {
  minWordLength: 3,
  maxWords: 100,
  excludeWords: "the,and,or,but,in,on,at,to,for,of,with,by,is,are,was,were,be,been,being,have,has,had,do,does,did,will,would,could,should,may,might,can,this,that,these,those,a,an,it,its,they,them,their,theirs,we,us,our,ours,you,your,yours,he,him,his,she,her,hers,i,me,my,mine,who,what,when,where,why,how,which,whom,whose,if,then,else,so,yet,nor,either,neither,both,all,any,some,many,much,few,little,more,most,less,least,very,quite,rather,too,also,just,only,even,still,already,again,once,twice,often,always,never,sometimes,usually,frequently,rarely,hardly,barely,almost,nearly,about,around,over,under,above,below,before,after,during,since,until,while,through,between,among,within,without,against,towards,upon,into,onto,across,along,down,up,out,off,away,back,here,there,everywhere,anywhere,somewhere,nowhere,whenever,now,today,tomorrow,yesterday,soon,late,early,first,last,next,previous,another,other,same,different,new,old,big,small,large,good,bad,best,worst,better,worse,right,wrong,true,false,yes,no,ok,okay,please,thank,thanks,hello,hi,bye,goodbye,sorry,excuse,pardon,\u0219i,sau,dar,\xEEns\u0103,pentru,cu,de,la,\xEEn,pe,prin,c\u0103tre,din,asupra,sub,dup\u0103,\xEEnainte,timp,ce,c\xE2nd,unde,cum,cine,care,al,ale,ai,au,avea,am,are,aveam,aveai,avea,avea\u021Bi,aveau,voi,va,vor,s\u0103,fie,fiind,fost,este,sunt,era,erau,fiu,fii,fim,fi\u021Bi,e\u0219ti,suntem,sunte\u021Bi,eram,erai,era\u021Bi,f\u0103cut,face,fac,faci,facem,face\u021Bi,f\u0103ceam,f\u0103ceai,f\u0103cea,f\u0103cea\u021Bi,f\u0103ceau,vei,vom,ve\u021Bi,a\u0219,a\u021Bi,ar,nu,da,foarte,mult,pu\u021Bin,mai,cel,cea,cei,cele,un,una,unor,unei,aceasta,acesta,acestea,ace\u0219tia,aceast\u0103,acest,aceste,ace\u0219ti,acea,acel,acele,acei,care,ce,ca,cum,tot,toat\u0103,to\u021Bi,toate,oricare,orice,cineva,ceva,nimeni,nimic,mereu,niciodat\u0103,uneori,adesea,rar,\xEEntotdeauna,iar,\xEEnc\u0103,deja,acum,atunci,apoi,ieri,azi,m\xE2ine,aici,acolo,oriunde,undeva,nic\u0103ieri,a\u0219a,astfel,altfel,poate,probabil,sigur,desigur,evident,bine\xEEn\u021Beles,normal,natural,p\xE2n\u0103,peste,dintre,printre,\xEEmpotriva,datorit\u0103,conform,referitor,legat,privind,av\xE2nd,fiind,f\u0103c\xE2nd,spun\xE2nd,zic\xE2nd,v\u0103z\xE2nd,\u0219tiind,put\xE2nd,trebuind,vr\xE2nd,dorind,\xEEntre,printre,c\xE2teva,c\xE2\u021Biva,fiecare,multe,pu\u021Bine,c\xE2te,c\xE2\u021Bi,c\xE2t\u0103,\xEEntr,dintr,\xEEnspre,\xEEnaintea,\xEEn,urma,deasupra,dedesubt,\xEEn\u0103untru,afar\u0103",
  includeTags: true,
  includeHeaders: true,
  refreshInterval: 5e3
};
var EchoesPlugin = class extends import_obsidian2.Plugin {
  constructor() {
    super(...arguments);
    this.refreshTimeout = null;
  }
  async onload() {
    await this.loadSettings();
    this.analyzer = new FrequencyAnalyzer(this.settings);
    this.wordCloudGenerator = new WordCloudGenerator();
    this.registerView(
      VIEW_TYPE_ECHOES,
      (leaf) => new EchoesView(leaf, this)
    );
    const ribbonIconEl = this.addRibbonIcon("bar-chart-2", "Echoes: Concept Frequency Analyzer", (evt) => {
      this.activateView();
    });
    ribbonIconEl.addClass("echoes-ribbon-class");
    this.addCommand({
      id: "open-echoes-view",
      name: "Open Echoes Analyzer",
      callback: () => {
        this.activateView();
      }
    });
    this.addCommand({
      id: "analyze-current-file",
      name: "Analyze Current File",
      editorCallback: (editor, view) => {
        this.analyzeCurrentFile(view.file);
      }
    });
    this.addSettingTab(new EchoesSettingTab(this.app, this));
    this.registerEvent(
      this.app.workspace.on("file-open", () => {
        this.refreshAnalysis();
      })
    );
    this.registerEvent(
      this.app.vault.on("modify", () => {
        this.refreshAnalysis();
      })
    );
  }
  onunload() {
    this.app.workspace.detachLeavesOfType(VIEW_TYPE_ECHOES);
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
    if (this.analyzer) {
      this.analyzer.updateSettings(this.settings);
    }
  }
  async activateView() {
    const { workspace } = this.app;
    let leaf = null;
    const leaves = workspace.getLeavesOfType(VIEW_TYPE_ECHOES);
    if (leaves.length > 0) {
      leaf = leaves[0];
    } else {
      leaf = workspace.getRightLeaf(false);
      await leaf.setViewState({ type: VIEW_TYPE_ECHOES, active: true });
    }
    workspace.revealLeaf(leaf);
  }
  async analyzeCurrentFile(file) {
    var _a;
    if (!file) {
      new import_obsidian2.Notice("No file selected");
      return;
    }
    try {
      const content = await this.app.vault.read(file);
      const analysis = this.analyzer.analyzeText(content, file.basename);
      const view = (_a = this.app.workspace.getLeavesOfType(VIEW_TYPE_ECHOES)[0]) == null ? void 0 : _a.view;
      if (view) {
        view.updateAnalysis([analysis]);
      } else {
        new import_obsidian2.Notice(`Found ${analysis.totalWords} words, ${analysis.uniqueWords} unique`);
      }
    } catch (error) {
      new import_obsidian2.Notice("Error analyzing file: " + error.message);
    }
  }
  refreshAnalysis() {
    if (this.refreshTimeout) {
      clearTimeout(this.refreshTimeout);
    }
    this.refreshTimeout = setTimeout(async () => {
      var _a;
      const view = (_a = this.app.workspace.getLeavesOfType(VIEW_TYPE_ECHOES)[0]) == null ? void 0 : _a.view;
      if (view) {
        await view.refreshAnalysis();
      }
    }, this.settings.refreshInterval);
  }
  getAnalyzer() {
    return this.analyzer;
  }
  getWordCloudGenerator() {
    return this.wordCloudGenerator;
  }
};
var EchoesSettingTab = class extends import_obsidian2.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian2.Setting(containerEl).setName("Minimum word length").setDesc("Minimum number of characters for words to be included in analysis").addText((text) => text.setPlaceholder("3").setValue(this.plugin.settings.minWordLength.toString()).onChange(async (value) => {
      const num = parseInt(value);
      if (!isNaN(num) && num > 0) {
        this.plugin.settings.minWordLength = num;
        await this.plugin.saveSettings();
      }
    }));
    new import_obsidian2.Setting(containerEl).setName("Maximum words to display").setDesc("Maximum number of words to show in visualizations").addText((text) => text.setPlaceholder("100").setValue(this.plugin.settings.maxWords.toString()).onChange(async (value) => {
      const num = parseInt(value);
      if (!isNaN(num) && num > 0) {
        this.plugin.settings.maxWords = num;
        await this.plugin.saveSettings();
      }
    }));
    new import_obsidian2.Setting(containerEl).setName("Exclude words").setDesc("Comma-separated list of words to exclude from analysis").addTextArea((text) => text.setPlaceholder("the,and,or,but...").setValue(this.plugin.settings.excludeWords).onChange(async (value) => {
      this.plugin.settings.excludeWords = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian2.Setting(containerEl).setName("Include tags").setDesc("Include hashtags in the frequency analysis").addToggle((toggle) => toggle.setValue(this.plugin.settings.includeTags).onChange(async (value) => {
      this.plugin.settings.includeTags = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian2.Setting(containerEl).setName("Include headers").setDesc("Include markdown headers in the frequency analysis").addToggle((toggle) => toggle.setValue(this.plugin.settings.includeHeaders).onChange(async (value) => {
      this.plugin.settings.includeHeaders = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian2.Setting(containerEl).setName("Auto-refresh interval").setDesc("How often to refresh analysis (in milliseconds)").addText((text) => text.setPlaceholder("5000").setValue(this.plugin.settings.refreshInterval.toString()).onChange(async (value) => {
      const num = parseInt(value);
      if (!isNaN(num) && num >= 1e3) {
        this.plugin.settings.refreshInterval = num;
        await this.plugin.saveSettings();
      }
    }));
  }
};
